# Алгебраические типы данных

## Коммутативно ли сложение и умножение АТД?

### Sum type

Сложение коммутативно, если мы задаем тип как сумму двух вариантов: `a+b`, то он означает, что значение может быть либо типа `a` либо типа `b`. Набор вариантов не меняется, меняется лишь порядок записи.

### Product type

Умножение коммутативно, если мы задаем тип как произведение: `a*b`, при котором значение имеет поля из типа `a` и из типа `b`. Набор полей остается тем же. 

Однако, в некоторых ЯП порядок полей может влиять на синтаксическое представление (например, порядок вариантов при сопоставлении с образцом).

## Поддержка АТД в Go 

Go не имеет прямой поддержки АТД, как в Haskell. Однако их можно эмулировать.

### Sum type

Возможно эмулировать при помощи интерфейсов, реализующие несколько структур, и типовых переключений (type switch).

### Product type

Структуры позволяют объединять несколько значений в один тип.

~~~go
type Person struct {
    Name string
    Age  int
}
~~~

## Определение двоичное дерева через АТД

~~~go
package main

import "fmt"

// BinaryTree — общий интерфейс для двоичного дерева.
type BinaryTree interface {
	isBinaryTree() // служебный метод для реализации интерфейса
}

// EmptyTree представляет пустое дерево.
type EmptyTree struct{}

// Реализация метода для EmptyTree.
func (EmptyTree) isBinaryTree() {}

// Node представляет узел дерева, содержащий значение и два поддерева.
type Node struct {
	Value       int
	Left, Right BinaryTree
}

// Реализация метода для Node.
func (Node) isBinaryTree() {}

func main() {
	// Пример создания двоичного дерева:
	//         10
	//        /  \
	//       5    15
	tree := Node{
		Value: 10,
		Left: Node{
			Value: 5,
			Left:  EmptyTree{},
			Right: EmptyTree{},
		},
		Right: Node{
			Value: 15,
			Left:  EmptyTree{},
			Right: EmptyTree{},
		},
	}

	// Демонстрация: выводим дерево
	fmt.Printf("Дерево: %+v\n", tree)
}
~~~